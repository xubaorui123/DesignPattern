# 策略模式

定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。

## 案例：气象站

此系统中的三个部分是气象站、WeatherData对象（追踪来自气象站的数据，并更新）和布告板（显示目前天气状况给用户看）。
需要完成的工作：建立一个应用，利用WeatherData对象取得数据，并更新三个布告板：目前状况、气象统计和天气预报。

```java
interface WeatherData {
    //以下三个方法各自返回最近的气象测量数据（分别为温度、湿度、气压）。
    float getTemperature();

    float getHumidity();

    float getPressure();

    /*
     * 需要将你的代码加到这个方法中，一旦气象测量更新，此方法会被调用
     */
    measurementsChanged();
}
```

### 已知

1. WeatherData类具有getter方法，可以取得三个测量值：温度、湿度与气压
2. 当新的测量数据备妥时，measurementsChanged（）方法就会被调用
3. 我们需要实现三个使用天气数据的布告板：“目前状况”布告、“气象统计”布告、“天气预报”布告。一旦WeatherData有新的测量，这些布告必须马上更新。
4. 此系统必须可扩展，让其他开发人员建立制定的布告板，用户可以随心所欲的添加或删除任何布告板。目前初始的布告板有三类：“目前状况”布告、“气象统计”布告、“天气预报”布告。

---

### v0

```java
interface WeatherData {
    void measurementsChanged() {

        //获取最新的测量值
        float temperature = getTemperature();
        float humidity = getHumidity();
        float pressure = getPressure();

        //更新布告板1
        //更新布告板2
        //更新布告板3
    }
}
```
> 初始版本中，将布告板作为一个统一的接口，里面包含update方法，可以通过调用update方法来更新布告板。  
> 每个布告板实现自己的更新方法

这里存在的问题是，如果新增加布告板，则需要改变measurementsChanged()方法。

### 定义观察者模式
[观察者模式：类图(Observer.puml)](/com/xubaorui/designpattern/L2_observer/Observer.puml)
> 这和一对多的关系有何关联？  
> 利用观察者模式，主题是具有状态的对象，并且可以控制这些状态。也就是说，有“一个”具有状态的主题。
> 另一方面，观察者使用这些状态，虽然这些状态并不属于他们。
> 有许多的观察者，依赖主题来告诉他们状态合适改变了。
> 这就产生一个关系：“一个”主题对“多个”观察者的关系。

> 其间的依赖是如何产生的？  
> 因为主题是真正拥有数据的人，观察者是主题的依赖者，
> 在数据变化时更新，这样比起让许多对象控制同一份数据来说，
> 可以得到更干净的oo设计。

### 松耦合的威力
**当两个对象之间松耦合，他们依然可以交互，但是不太清楚彼此的细节。<br/>观察者模式提供了一种对象设计，让主题和观察者之间松耦合。**
> 为什么呢？  
> 1. （**不需要知道细节**）关于观察者的一切，主题只知道观察者实现了某个接口。主题不需要知道观察者的具体类是谁、做了些什么或任何其他细节。  
> 2. （**任意新增或删除观察者**）任何时候都可以增加新的观察者。因为主题唯一依赖的东西是一个实现Observer接口的对象列表，所以我们可以随时增加观察者。
> 事实上，在运行时我们可以用新的观察者取代现有的观察者，主题不会收到任何影响。通用的，也可以在任何时候删除某些观察者。
> 3. （**增加新类型观察者时不用修改主题代码**）有类型的观察者出现时，主题的代码不需要修改。加入我们有个新的具体类需要当观察者，
> 我们不需要为了兼容新类型而修改主题代码，所有要做的就是在新的类里实现此观察者接口，然后注册为观察者即可。
> 主题不在乎别的，它只会发送通知给所有实现了观察者接口的对象。
> 4. （**可以独立复用主题或观察者**）我们可以独立的复用主题或观察者。如果我们在其他地方需要使用主题或观察者，可以轻易的复用，因为二者并非紧耦合。
> 5. （**接口不变，改变其中一方，不会影响另一方**）改变主题或观察者其中一方，并不会影响另一方。因为两者是松耦合的，
> 所以只要他们之间的接口仍然被遵守，我们就可以自由地改变他们。


### 设计原则
为了交互对象之间的松耦合设计而努力。
> 松耦合的设计之所以能让我们建立有弹性的oo系统，能够应对变化，是因为对象之间的相互依赖降到了最低。



