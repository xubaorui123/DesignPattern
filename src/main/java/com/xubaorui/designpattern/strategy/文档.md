# 策略模式
    定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
## 案例：鸭子

### 第一版需求V0

所有的鸭子都会呱呱叫，也会游泳，但是每只鸭子的外观不同。
> 实现方式是，创建鸭子超类，在超类中实现共有方法（呱呱叫、游泳），每个鸭子实现自己独有的方法（外观）。

---

### 第二版需求V1

需要让鸭子可以飞
> 实现方式是，在超类中添加fly方法，这样所有鸭子就都可以飞了

### 第三版需求V2

有一些鸭子不会飞，有一些鸭子不会叫
> 思考：  
> 1.可以在子类中利用重写进行覆盖，但是如果类的数量很多，修改的工作量就会非常大  
> 2.可以使用接口的方式，声明flyable和quackable接口，如果鸭子有这种行为，就实现对应的接口，
> 如果两只鸭子的行为实现方式相同（所有真实的鸭子都是用翅膀飞行），使用这种方式就会产生许多相同的代码；
> 如果类的数量很多，工作量同样很大。

> 实现的方式是,把鸭子的经常变化行为抽取出来，封装成对象；  
> 在鸭子类中通过构造函数声明，行为的实现通过新定义的类来决定，不需要在鸭子类本身中进行编码。  
> 还可以通过setter方法替换行为，使行为可以随时替换

>###设计原则
>>- 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混在一起。  
> 
>>- 多用组合，少用继承。  
>>使用组合建立系统具有很大的弹性，不仅可以将算法封装成类，更可以“在运行时动态地改变行为”。
